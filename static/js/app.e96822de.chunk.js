(this.webpackJsonp=this.webpackJsonp||[]).push([[0],{198:function(e,n){},205:function(e,n,t){"use strict";t.d(n,"a",(function(){return U}));var r=t(0),s=t.n(r),o=t(206),a=(t(325),t(175)),i=t(331),c=t(330),l=t(15),d=t.n(l),f=t(13),u=t.n(f),m=t(21),p=t.n(m),h=t(99),_=t(40),b=t(1),g=t(197),y=t.n(g);function x(e){return null===e||""===e?"":(e=e.toString()).replace(/(<([^>]+)>)/gi,"")}var C=function(e,n){console.error(e),console.error("Failed to load data from "+n)},v=function(e){var n;return p.a.async((function(t){for(;;)switch(t.prev=t.next){case 0:return t.prev=0,t.next=3,p.a.awrap(fetch(e));case 3:return n=t.sent,t.abrupt("return",n.text());case 7:return t.prev=7,t.t0=t.catch(0),C(t.t0,e),t.abrupt("return","");case 11:case"end":return t.stop()}}),null,null,[[0,7]],Promise)},w=function(e){var n;return p.a.async((function(t){for(;;)switch(t.prev=t.next){case 0:return t.prev=0,t.next=3,p.a.awrap(fetch(e));case 3:return n=t.sent,t.next=6,p.a.awrap(n.json());case 6:return t.abrupt("return",t.sent);case 9:return t.prev=9,t.t0=t.catch(0),C(t.t0,e),t.abrupt("return",{});case 13:case"end":return t.stop()}}),null,null,[[0,9]],Promise)},k=function(){var e,n,t,r,s,o;return p.a.async((function(a){for(;;)switch(a.prev=a.next){case 0:return a.next=2,p.a.awrap(w("https://foorenxiang.github.io/static/servedNotes.json"));case 2:for(t in e=a.sent,n={},e)r=y()(t),s=e[t],i=s,o=new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$","i").test(i)?s:"https://raw.githubusercontent.com/foorenxiang/notes/main/"+s,n[t]={title:r,url:o};return a.abrupt("return",n);case 6:case"end":return a.stop()}var i}),null,null,null,Promise)},j=function(e){var n=e.split(".");return n[n.length-1].toLowerCase()},P=function(e){var n;return p.a.async((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,p.a.awrap(v(e));case 2:return n=t.sent,t.abrupt("return",x(n));case 4:case"end":return t.stop()}}),null,null,null,Promise)},S=function(e){var n,t,r,s,o;return p.a.async((function(a){for(;;)switch(a.prev=a.next){case 0:return t="."+e,a.next=3,p.a.awrap(w("https://gist.githubusercontent.com/foorenxiang/510c312f129b98a677329fd5d491e4e5/raw/211547723b4621a622fc56978d74aa416cbd1729/Programming_Languages_Extensions.json"));case 3:return r=a.sent,s=function(e){return"extensions"in e&&!!e.extensions.find((function(e){return t===e}))},o=null==(n=r.find((function(e){return s(e)})))?void 0:n.name,a.abrupt("return",o);case 7:case"end":return a.stop()}}),null,null,null,Promise)},A=function(e,n){var t,r,s;return p.a.async((function(o){for(;;)switch(o.prev=o.next){case 0:return o.next=2,p.a.awrap(v(e));case 2:return t=o.sent,o.next=5,p.a.awrap(S(n));case 5:return r=o.sent,s=function(e){return""+(r?"### "+r+" source file (."+n+")\n":"### ."+n+" source file \n")+("``` "+r+"\n")+e+"```"},o.abrupt("return",s(t));case 8:case"end":return o.stop()}}),null,null,null,Promise)},T=function(e,n){return"From source: "+e+"\n"+n},D=function(e){var n;return p.a.async((function(t){for(;;)switch(t.prev=t.next){case 0:if("md"!==(n=j(e))){t.next=7;break}return t.next=4,p.a.awrap(P(e));case 4:t.t0=t.sent,t.next=10;break;case 7:return t.next=9,p.a.awrap(A(e,n));case 9:t.t0=t.sent;case 10:return t.abrupt("return",t.t0);case 11:case"end":return t.stop()}}),null,null,null,Promise)},B=function(e){var n;return p.a.async((function(t){for(;;)switch(t.prev=t.next){case 0:return t.t0=T,t.t1=e,t.next=4,p.a.awrap(D(e));case 4:return t.t2=t.sent,n=(0,t.t0)(t.t1,t.t2),t.abrupt("return",n);case 7:case"end":return t.stop()}}),null,null,null,Promise)},I={"Python Design Patterns":'## **Design Pattern Notes from [Linkedin Learning](https://www.linkedin.com/learning/python-design-patterns)**\n<br/>\n\n# Creational Patterns\n\n## Factory\n### Problem:\n1. Uncertainties in types of objects\n2. Decisions on what classes to be used can only be made at runtime\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Dog:\n\n    """A simple dog class"""\n\n    def __init__(self, name):\n        self._name = name\n\n    def speak(self):\n        return "Woof!"\n\n\nclass Cat:\n\n    """A simple dog class"""\n\n    def __init__(self, name):\n        self._name = name\n\n    def speak(self):\n        return "Meow!"\n\n\ndef get_pet(pet="dog"):\n\n    """The factory method"""\n    """Document the classes created that this factory method can use to instantiate new objects"""\n    """To create a new object, just call this pattern and pass in the desired class as its input argument"""\n\n    """this dict constructor is used to keep a manifest of classes and its desired constructors that can be accessed"""\n    pets = dict(dog=Dog("Hope"), cat=Cat("Peace"))\n\n    return pets[pet]\n\n\n""" Call the factory method to create new objects"""\nd = get_pet("dog")\n\nprint(d.speak())\n\nc = get_pet("cat")\n\nprint(c.speak())\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n# Abstract Factory\n### Problem:\n1. User expectation yields **multiple**, related objects\n\n### Solution:\n1. Abstract factory e.g. pet factory\n2. Concrete factory e.g. dog factory and cat factory\n3. Abstract product\n4. Concrete product: dog and dog food; cat and cat food\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Dog:\n    """One of the objects to be returned"""\n\n    def speak(self):\n        return "Woof!"\n\n    def __str__(self):\n        return "Dog"\n\n\nclass DogFactory:\n    """Concrete Factory"""\n\n    def get_pet(self):\n        """Returns a Dog object"""\n        return Dog()\n\n    def get_food(self):\n        """Returns a Dog Food object"""\n        return "Dog Food!"\n\n\nclass PetStore:\n    """PetStore houses our Abstract Factory"""\n    """Used to invoke methods in the concrete factory that is passed into this abstract factory\'s constructor"""\n    """Essentially acting as an interface"""\n\n    def __init__(self, pet_factory=None):\n        """pet_factory is our Abstract Factory"""\n\n        self._pet_factory = pet_factory\n\n    def show_pet(self):\n        """Utility method to display the details of the objects retured by the DogFactory"""\n\n        pet = self._pet_factory.get_pet()\n        pet_food = self._pet_factory.get_food()\n\n        print("Our pet is \'{}\'!".format(pet))\n        print("Our pet says hello by \'{}\'".format(pet.speak()))\n        print("Its food is \'{}\'!".format(pet_food))\n\n\n# Create a Concrete Factory\nfactory = DogFactory()\n\n# Create a pet store housing our Abstract Factory\nshop = PetStore(factory)\n\n# Invoke the utility method to show the details of our pet\nshop.show_pet()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Singleton\n### Problem:\n1. Only one instance to be instantiated form a class\n2. Create global variable in an objected-oriented way using a singleton\n### Solution:\n1. Module\n   1. Shared by multiple objects\n2. Borg design pattern\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Borg:\n    """The Borg pattern makes the class attributes global"""\n\n    _shared_data = {}  # Attribute dictionary\n\n    def __init__(self):\n        self.__dict__ = self._shared_data  # Make it an attribute dictionary\n\n\nclass Singleton(Borg):  # Inherits from the Borg class\n    """This class now shares all its attributes among its various instances"""\n\n    # This essenstially makes the singleton objects an object-oriented global variable\n\n    def __init__(self, **kwargs):\n        Borg.__init__(self)\n        self._shared_data.update(\n            kwargs\n        )  # Update the attribute dictionary by inserting a new key-value pair\n\n    def __str__(self):\n        return str(self._shared_data)  # Returns the attribute dictionary for printing\n\n\n# Let\'s create a singleton object and add our first acronym\nx = Singleton(HTTP="Hyper Text Transfer Protocol")\n# Print the object\nprint(x)\n\n# Let\'s create another singleton object and if it refers to the same attribute dictionary by adding another acronym.\ny = Singleton(SNMP="Simple Network Management Protocol")\n# Print the object\nprint(y)\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Builder\n### Problem:\n1. Excessive number of constructors\n\n### Solution:\n1. Director\n2. Abstract Builder: interfaces\n3. Concrete Builder: implements the interfaces\n4. Product: object being built\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Director:\n    """Director"""\n\n    def __init__(self, builder):\n        self._builder = builder\n\n    def construct_car(self):\n        self._builder.create_new_car()\n        self._builder.add_model()\n        self._builder.add_tires()\n        self._builder.add_engine()\n\n    def get_car(self):\n        return self._builder.car\n\n\nclass Builder:\n    """Abstract Builder"""\n\n    def __init__(self):\n        self.car = None\n\n    def create_new_car(self):\n        self.car = Car()\n\n\nclass SkyLarkBuilder(Builder):\n    """Concrete Builder --\x3e provides parts and tools to work on the parts"""\n\n    def add_model(self):\n        self.car.model = "Skylark"\n\n    def add_tires(self):\n        self.car.tires = "Regular tires"\n\n    def add_engine(self):\n        self.car.engine = "Turbo engine"\n\n\nclass Car:\n    """Product"""\n\n    def __init__(self):\n        self.model = None\n        self.tires = None\n        self.engine = None\n\n    def __str__(self):\n        return "{} | {} | {}".format(self.model, self.tires, self.engine)\n\n\nbuilder = SkyLarkBuilder()\ndirector = Director(builder)\ndirector.construct_car()\ncar = director.get_car()\nprint(car)\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n##  \n### Problem:\n1. Creating many identical objects individually becomes expensive\n2. Cloning could be a good alternative to creating individual objects one at a time\n### Solution:\n1. Creating a prototypical **instance** first\n2. Simply clone the prototypical instance whenever a replica is needed\n\x3c!-- Codeblock start --\x3e\n``` python\nimport copy\n\n\nclass Prototype:\n    def __init__(self):\n        self._objects = {}\n\n    def register_object(self, name, obj):\n        """Register object to be cloned"""\n        self._objects[name] = obj\n\n    def unregister_object(self, name):\n        """Unregister an object"""\n        del self._objects[name]\n\n    def clone(self, name, **attr):\n        """Clone a registered object and update its attributes"""\n        obj = copy.deepcopy(self._objects.get(name))\n        obj.__dict__.update(attr)\n        return obj\n\n\nclass Car:\n    def __init__(self):\n        self.name = "Skylark"\n        self.color = "Red"\n        self.options = "Ex"\n\n    def __str__(self):\n        return "{} | {} | {}".format(self.name, self.color, self.options)\n\n\nc = Car()\nprototype = Prototype()\nprototype.register_object("skylark", c)\n\nc1 = prototype.clone("skylark")\n\nprint(c1)\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n# Structural Patterns\n\n## Decorator\n### Problem:\n1. Need to add new features to existing object\n\n### Solution:\n1. Functions, use built-in decorator feature\n\x3c!-- Codeblock start --\x3e\n``` python\nfrom functools import wraps\n\n\ndef make_blink(function):\n    """Defines the decorator"""\n\n    # This makes the decorator transparent in terms of its name and docstring\n    @wraps(function)\n\n    # Define the inner function\n    def decorator():\n        # Grab the return value of the function being decorated\n        ret = function()\n\n        # Add new functionality to the function being decorated\n        return "<blink>" + ret + "</blink>"\n\n    return decorator\n\n\n# Apply the decorator here!\n@make_blink\ndef hello_world():\n    """Original function!"""\n\n    return "Hello, World!"\n\n\n# Check the result of decorating\nprint(hello_world())\n\n# Check if the function name is still the same name of the function being decorated\nprint(hello_world.__name__)\n\n# Check if the docstring is still the same as that of the function being decorated\nprint(hello_world.__doc__)\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Proxy\n### Problem:\n1. Postpone object creation until absolutely necessary\n2. Find a placeholder\n\n### Solution:\n1. Clients: interacting with a proxy\n2. Proxy: responsible for creating the resource intensive objects\n\x3c!-- Codeblock start --\x3e\n``` python\nimport time\n\n\nclass Producer:\n    """Define the \'resource-intensive\' object to instantiate!"""\n\n    def produce(self):\n        print("Producer is working hard!")\n\n    def meet(self):\n        print("Producer has time to meet you now!")\n\n\nclass Proxy:\n    """ "Define the \'relatively less resource-intensive\' proxy to instantiate as a middleman"""\n\n    def __init__(self):\n        self.occupied = "No"\n        self.producer = None\n\n    def produce(self):\n        """Check if Producer is available"""\n        print("Artist checking if Producer is available ...")\n\n        if self.occupied == "No":\n            # If the producer is available, create a producer object!\n            self.producer = Producer()\n            time.sleep(2)\n\n            # Make the prodcuer meet the guest!\n            self.producer.meet()\n\n        else:\n            # Otherwise, don\'t instantiate a producer\n            time.sleep(2)\n            print("Producer is busy!")\n\n\n# Instantiate a Proxy\np = Proxy()\n\n# Make the proxy: Artist produce until Producer is available\np.produce()\n\n# Change the state to \'occupied\'\np.occupied = "Yes"\n\n# Make the Producer produce\np.produce()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Adapter\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Korean:\n    """Korean speaker"""\n\n    def __init__(self):\n        self.name = "Korean"\n\n    def speak_korean(self):\n        return "An-neyong?"\n\n\nclass British:\n    """English speaker"""\n\n    def __init__(self):\n        self.name = "British"\n\n    # Note the different method name here!\n    def speak_english(self):\n        return "Hello!"\n\n\nclass Adapter:\n    """This changes the generic method name to individualized method names"""\n\n    def __init__(self, object, **adapted_method):\n        """Change the name of the method"""\n        self._object = object\n\n        # Add a new dictionary item that establishes the mapping between the generic method name: speak() and the concrete method\n        # For example, speak() will be translated to speak_korean() if the mapping says so\n        self.__dict__.update(adapted_method)\n\n    def __getattr__(self, attr):\n        """Simply return the rest of attributes!"""\n        return getattr(self._object, attr)\n\n\n# List to store speaker objects\nobjects = []\n\n# Create a Korean object\nkorean = Korean()\n\n# Create a British object\nbritish = British()\n\n# Append the objects to the objects list\nobjects.append(Adapter(korean, speak=korean.speak_korean))\nobjects.append(Adapter(british, speak=british.speak_english))\n\n\nfor obj in objects:\n    print("{} says \'{}\'\n".format(obj.name, obj.speak()))\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Composite\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Component(object):\n    """Abstract class"""\n\n    def __init__(self, *args, **kwargs):\n        pass\n\n    def component_function(self):\n        pass\n\n\nclass Child(Component):  # Inherits from the abstract class, Component\n    """Concrete class"""\n\n    def __init__(self, *args, **kwargs):\n        Component.__init__(self, *args, **kwargs)\n\n        # This is where we store the name of your child item!\n        self.name = args[0]\n\n    def component_function(self):\n        # Print the name of your child item here!\n        print("{}".format(self.name))\n\n\nclass Composite(Component):  # Inherits from the abstract class, Component\n    """Concrete class and maintains the tree recursive structure"""\n\n    def __init__(self, *args, **kwargs):\n        Component.__init__(self, *args, **kwargs)\n\n        # This is where we store the name of the composite object\n        self.name = args[0]\n\n        # This is where we keep our child items\n        self.children = []\n\n    def append_child(self, child):\n        """Method to add a new child item"""\n        self.children.append(child)\n\n    def remove_child(self, child):\n        """Method to remove a child item"""\n        self.children.remove(child)\n\n    def component_function(self):\n\n        # Print the name of the composite object\n        print("{}".format(self.name))\n\n        # Iterate through the child objects and invoke their component function printing their names\n        for i in self.children:\n            i.component_function()\n\n\n# Build a composite submenu 1\nsub1 = Composite("submenu1")\n\n# Create a new child sub_submenu 11\nsub11 = Child("sub_submenu 11")\n# Create a new Child sub_submenu 12\nsub12 = Child("sub_submenu 12")\n\n# Add the sub_submenu 11 to submenu 1\nsub1.append_child(sub11)\n# Add the sub_submenu 12 to submenu 1\nsub1.append_child(sub12)\n\n# Build a top-level composite menu\ntop = Composite("top_menu")\n\n# Build a submenu 2 that is not a composite\nsub2 = Child("submenu2")\n\n# Add the composite submenu 1 to the top-level composite menu\ntop.append_child(sub1)\n\n# Add the plain submenu 2 to the top-level composite menu\ntop.append_child(sub2)\n\n# Let\'s test if our Composite pattern works!\ntop.component_function()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Bridge\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass DrawingAPIOne(object):\n    """Implementation-specific abstraction: concrete class one"""\n\n    def draw_circle(self, x, y, radius):\n        print("API 1 drawing a circle at ({}, {} with radius {}!)".format(x, y, radius))\n\n\nclass DrawingAPITwo(object):\n    """Implementation-specific abstraction: concrete class two"""\n\n    def draw_circle(self, x, y, radius):\n        print("API 2 drawing a circle at ({}, {} with radius {}!)".format(x, y, radius))\n\n\nclass Circle(object):\n    """Implementation-independent abstraction: for example, there could be a rectangle class!"""\n\n    def __init__(self, x, y, radius, drawing_api):\n        """Initialize the necessary attributes"""\n        self._x = x\n        self._y = y\n        self._radius = radius\n        self._drawing_api = drawing_api\n\n    def draw(self):\n        """Implementation-specific abstraction taken care of by another class: DrawingAPI"""\n        self._drawing_api.draw_circle(self._x, self._y, self._radius)\n\n    def scale(self, percent):\n        """Implementation-independent"""\n        self._radius *= percent\n\n\n# Build the first Circle object using API One\ncircle1 = Circle(1, 2, 3, DrawingAPIOne())\n# Draw a circle\ncircle1.draw()\n\n# Build the second Circle object using API Two\ncircle2 = Circle(2, 3, 4, DrawingAPITwo())\n# Draw a circle\ncircle2.draw()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n# Behavioral Patterns\n\n## Observer\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Subject(object):  # Represents what is being \'observed\'\n    def __init__(self):\n        self._observers = (\n            []\n        )  # This where references to all the observers are being kept\n        # Note that this is a one-to-many relationship: there will be one subject to be observed by multiple _observers\n\n    def attach(self, observer):\n        if (\n            observer not in self._observers\n        ):  # If the observer is not already in the observers list\n            self._observers.append(observer)  # append the observer to the list\n\n    def detach(self, observer):  # Simply remove the observer\n        try:\n            self._observers.remove(observer)\n        except ValueError:\n            pass\n\n    def notify(self, modifier=None):\n        for observer in self._observers:  # For all the observers in the list\n            if (\n                modifier != observer\n            ):  # Don\'t notify the observer who is actually updating the temperature\n                observer.update(self)  # Alert the observers!\n\n\nclass Core(Subject):  # Inherits from the Subject class\n    def __init__(self, name=""):\n        Subject.__init__(self)\n        self._name = name  # Set the name of the core\n        self._temp = 0  # Initialize the temperature of the core\n\n    @property  # Getter that gets the core temperature\n    def temp(self):\n        return self._temp\n\n    @temp.setter  # Setter that sets the core temperature\n    def temp(self, temp):\n        self._temp = temp\n        self.notify()  # Notify the observers whenever somebody changes the core temperature\n\n\nclass TempViewer:\n    def update(\n        self, subject\n    ):  # Alert method that is invoked when the notify() method in a concrete subject is invoked\n        print(\n            "Temperature Viewer: {} has Temperature {}".format(\n                subject._name, subject._temp\n            )\n        )\n\n\n# Let\'s create our subjects\nc1 = Core("Core 1")\nc2 = Core("Core 2")\n\n# Let\'s create our observers\nv1 = TempViewer()\nv2 = TempViewer()\n\n# Let\'s attach our observers to the first core\nc1.attach(v1)\nc1.attach(v2)\n\n# Let\'s change the temperature of our first core\nc1.temp = 80\nc1.temp = 90\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Visitor\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass House(object):  # The class being visited\n    def accept(self, visitor):\n        """Interface to accept a visitor"""\n        visitor.visit(self)  # Triggers the visiting operation!\n\n    def work_on_hvac(self, hvac_specialist):\n        print(\n            self, "worked on by", hvac_specialist\n        )  # Note that we now have a reference to the HVAC specialist object in the house object!\n\n    def work_on_electricity(self, electrician):\n        print(\n            self, "worked on by", electrician\n        )  # Note that we now have a reference to the electrician object in the house object!\n\n    def __str__(self):\n        """Simply return the class name when the House object is printed"""\n        return self.__class__.__name__\n\n\nclass Visitor(object):\n    """Abstract visitor"""\n\n    def __str__(self):\n        """Simply return the class name when the Visitor object is printed"""\n        return self.__class__.__name__\n\n\nclass HvacSpecialist(Visitor):  # Inherits from the parent class, Visitor\n    """Concrete visitor: HVAC specialist"""\n\n    def visit(self, house):\n        house.work_on_hvac(\n            self\n        )  # Note that the visitor now has a reference to the house object\n\n\nclass Electrician(Visitor):  # Inherits from the parent class, Visitor\n    """Concrete visitor: electrician"""\n\n    def visit(self, house):\n        house.work_on_electricity(\n            self\n        )  # Note that the visitor now has a reference to the house object\n\n\n# Create an HVAC specialist\nhv = HvacSpecialist()\n# Create an electrician\ne = Electrician()\n\n# Create a house\nhome = House()\n\n# Let the house accept the HVAC specialist and work on the house by invoking the visit() method\nhome.accept(hv)\n\n# Let the house accept the electrician and work on the house by invoking the visit() method\nhome.accept(e)\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Iterator\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\ndef count_to(count):\n    """Our iterator implementation"""\n\n    # Our list\n    numbers_in_german = ["eins", "zwei", "drei", "vier", "funf"]\n\n    # Our built-in iterator\n    # Creates a tuple such as (1, "eins")\n    iterator = zip(range(count), numbers_in_german)\n\n    # Iterate through our iterable list\n    # Extract the German numbers\n    # Put them in a generator called number\n    for position, number in iterator:\n\n        # Returns a \'generator\' containing numbers in German\n        yield number\n\n\n# Let\'s test the generator returned by our iterator\nfor num in count_to(3):\n    print("{}".format(num))\n\nfor num in count_to(4):\n    print("{}".format(num))\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Strategy\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nimport types  # Import the types module\n\n\nclass Strategy:\n    """The Strategy Pattern class"""\n\n    def __init__(self, function=None):\n        self.name = "Default Strategy"\n\n        # If a reference to a function is provided, replace the execute() method with the given function\n        if function:\n            self.execute = types.MethodType(function, self)\n\n    def execute(\n        self,\n    ):  # This gets replaced by another version if another strategy is provided.\n        """The defaut method that prints the name of the strategy being used"""\n        print("{} is used!".format(self.name))\n\n\n# Replacement method 1\ndef strategy_one(self):\n    print("{} is used to execute method 1".format(self.name))\n\n\n# Replacement method 2\ndef strategy_two(self):\n    print("{} is used to execute method 2".format(self.name))\n\n\n# Let\'s create our default strategy\ns0 = Strategy()\n# Let\'s execute our default strategy\ns0.execute()\n\n# Let\'s create the first varition of our default strategy by providing a new behavior\ns1 = Strategy(strategy_one)\n# Let\'s set its name\ns1.name = "Strategy One"\n# Let\'s execute the strategy\ns1.execute()\n\ns2 = Strategy(strategy_two)\ns2.name = "Strategy Two"\ns2.execute()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n\n## Chain of responsibility\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Handler:  # Abstract handler\n    """Abstract Handler"""\n\n    def __init__(self, successor):\n        self._successor = successor  # Define who is the next handler\n\n    def handle(self, request):\n        handled = self._handle(request)  # If handled, stop here\n\n        # Otherwise, keep going\n        if not handled:\n            self._successor.handle(request)\n\n    def _handle(self, request):\n        raise NotImplementedError("Must provide implementation in subclass!")\n\n\nclass ConcreteHandler1(Handler):  # Inherits from the abstract handler\n    """Concrete handler 1"""\n\n    def _handle(self, request):\n        if 0 < request <= 10:  # Provide a condition for handling\n            print("Request {} handled in handler 1".format(request))\n            return True  # Indicates that the request has been handled\n\n\nclass DefaultHandler(Handler):  # Inherits from the abstract handler\n    """Default handler"""\n\n    def _handle(self, request):\n        """If there is no handler available"""\n        # No condition checking since this is a default handler\n        print("End of chain, no handler for {}".format(request))\n        return True  # Indicates that the request has been handled\n\n\nclass Client:  # Using handlers\n    def __init__(self):\n        self.handler = ConcreteHandler1(\n            DefaultHandler(None)\n        )  # Create handlers and use them in a sequence you want\n        # Note that the default handler has no successor\n\n    def delegate(\n        self, requests\n    ):  # Send your requests one at a time for handlers to handle\n        for request in requests:\n            self.handler.handle(request)\n\n\n# Create a client\nc = Client()\n\n# Create requests\nrequests = [2, 5, 30]\n\n# Send the requests\nc.delegate(requests)\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n# Design Best Practices\n\n# Consistency\n# Other qualities\n\n## **Advanced Design Pattern Notes from [Linkedin Learning](https://www.linkedin.com/learning/python-advanced-design-patterns)**\n<br/>\n\n## Facade\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass SubsystemA:\n\n\tdef method1(self):\n\t\tprint(\'SubsystemA method1 ...\')\n\t\t\n\tdef method2(self):\n\t\tprint(\'SubsystemA method2 ...\')\n\nclass SubsystemB:\n\t\n\tdef method1(self):\n\t\tprint(\'SubsystemB method1 ...\')\n\t\t\n\tdef method2(self):\n\t\tprint(\'SubsystemB method2 ...\')\n\nclass Facade:\n\n\tdef __init__(self):\n\t\tself._subsystem_A = SubsystemA()\n\t\tself._subsystem_B = SubsystemB()\n\n\tdef method(self):\n\t\tself._subsystem_A.method1()\n\t\tself._subsystem_A.method2()\n\t\t\n\t\tself._subsystem_B.method1()\n\t\tself._subsystem_B.method2()\n\ndef main():\n\tfacade = Facade()\n\tfacade.method()\n\nif __name__ == "__main__":\n\tmain()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n## Command\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass Command:\n\tdef execute(self):\n\t\tpass\n\nclass Copy(Command):\n\tdef execute(self):\n\t\tprint("Copying ...")\n\nclass Paste(Command):\n\tdef execute(self):\n\t\tprint("Pasting ...")\n\nclass Save(Command):\n\tdef execute(self):\n\t\tprint("Saving ...")\n\nclass Macro:\n\tdef __init__(self):\n\t\tself.commands = []\n\n\tdef add(self, command):\n\t\tself.commands.append(command)\n\n\tdef run(self):\n\t\tfor o in self.commands:\n\t\t\to.execute()\n\ndef main():\n\tmacro = Macro()\n\tmacro.add(Copy())\n\tmacro.add(Paste())\n\tmacro.add(Save())\n\tmacro.run()\n\nif __name__ == "__main__":\n\tmain()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n## Interpreter\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nfrom abc import ABC, abstractmethod\n\nclass AbstractExpression():\n\n\t@abstractmethod\n\tdef interpret(self):\n\t\tpass\n\nclass NonterminalExpression(AbstractExpression):\n\n\tdef __init__(self, expression):\n\t\tself._expression = expression\n\n\tdef interpret(self):\n\t\tprint("Non-terminal expression being interpreted ...")\n\t\tself._expression.interpret()\n\nclass TerminalExpression(AbstractExpression):\n\n\tdef interpret(self):\n\t\tprint("Terminal expression being interpreted ...")\n\ndef main():\n\n\tast = NonterminalExpression(NonterminalExpression(TerminalExpression()))\n\tast.interpret()\n\nif __name__ == "__main__":\n\tmain()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n## Mediator\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nimport sys\n\nclass Colleague(object):\n\tdef __init__(self, mediator, id):\n\t\tself._mediator = mediator\n\t\tself._id = id\n\n\tdef getID(self):\n\t\treturn self._id\n\n\tdef send(self, msg):\n\t\tpass\n\n\tdef receive(self, msg):\n\t\tpass\n\nclass ConcreteColleague(Colleague):\n\tdef __init__(self, mediator, id):\n\t\tsuper().__init__(mediator, id)\n\n\tdef send(self, msg):\n\t\tprint("Message \'" + msg + "\' sent by Colleague " + str(self._id))\n\t\tself._mediator.distribute(self, msg)\n\n\tdef receive(self, msg):\n\t\tprint("Message \'" + msg + "\' received by Colleague " + str(self._id))\n\n\nclass Mediator:\n\tdef add(self, colleague):\n\t\tpass\n\n\tdef distribute(self, sender, msg):\n\t\tpass\n\nclass ConcreteMediator(Mediator):\n\tdef __init__(self):\n\t\tMediator.__init__(self)\n\t\tself._colleague = []\n\n\tdef add(self, colleague):\n\t\tself._colleague.append(colleague)\n\n\tdef distribute(self, sender, msg):\n\t\tfor colleague in self._colleague:\n\t\t\tif colleague.getID() != sender.getID():\n\t\t\t\tcolleague.receive(msg)\n\n\ndef main():\n\tmediator = ConcreteMediator()\n\n\tc1 = ConcreteColleague(mediator, 1)\n\tc2 = ConcreteColleague(mediator, 2)\n\tc3 = ConcreteColleague(mediator, 3)\n\n\tmediator.add(c1)\n\tmediator.add(c2)\n\tmediator.add(c3)\n\n\tc1.send("Good Morning!")\n\nif __name__ == "__main__":\n\tmain()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n## Memento\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nimport pickle\n\nclass Originator:\n\n\tdef __init__(self):\n\t\tself._state = None\n\n\tdef create_memento(self):\n\t\treturn pickle.dumps(vars(self))\n\n\tdef set_memento(self, memento):\n\t\tprevious_state = pickle.loads(memento)\n\t\tvars(self).clear\n\t\tvars(self).update(previous_state)\n\ndef main():\n\toriginator = Originator()\n\n\tprint(vars(originator))\n\n\tmemento = originator.create_memento()\n\t\n\toriginator._state = True\n\n\tprint(vars(originator))\n\n\toriginator.set_memento(memento)\n\n\tprint(vars(originator))\n\nif __name__ == "__main__":\n\tmain()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n## State\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nclass AtmState():\n\n\tname = "state"\n\tallowed = []\n\n\tdef goNext(self, state):\n\t\tif state.name in self.allowed:\n\t\t\tprint("Current State: ", self, " switched to: ", state.name)\n\t\t\tself.__class__ = state\n\n\t\telse:\n\t\t\tprint("Current State: ", self, " switching to: ", state.name, " not possible!")\n\n\tdef __str__(self):\n\t\treturn self.name\n\nclass Off(AtmState):\n\n\tname = "off"\n\tallowed = [\'on\']\n\nclass On(AtmState):\n\n\tname = "on"\n\tallowed = [\'off\']\n\nclass ATM():\n\t\n\tdef __init__(self):\n\t\tself.current = Off()\n\n\tdef setState(self, state):\n\t\tself.current.goNext(state)\n\ndef main():\n\tatm = ATM()\n\n\tatm.setState(On)\n\tatm.setState(Off)\n\tatm.setState(Off)\n\nif __name__ == "__main__":\n\tmain()\n\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n\n## Template\n### Problem:\n\n### Solution:\n\x3c!-- Codeblock start --\x3e\n``` python\nimport sys\n\nfrom abc import ABC, abstractmethod\n\nclass AbstractClass(ABC):\n#This class inherit from Abstract Base Class to allow the use of the @abstractmethod decorator\n    \n\tdef template_method(self):\n\t\t"""Ths is the template method that contains a collection of \n\t\tmethods to stay the same, to be overriden, and to be overriden optionally.\n\t\t"""\n\n\t\tself.__always_do_this()\n\t\tself.do_step_1()\n\t\tself.do_step_2()\n\t\tself.do_this_or()\n\n\tdef __always_do_this(self):\n\t\t#This is a protected method that should not be overriden.\n\n\t\tname = sys._getframe().f_code.co_name\n\t\tprint(\'{}.{}\'.format(self.__class__.__name__, name))\n\n\t@abstractmethod\n\tdef do_step_1(self):\n\t\t#This method should be overriden\n\t\tpass\n\n\t@abstractmethod\n\tdef do_step_2(self):\n\t\t#This method should be overriden\n\t\tpass\n\n\tdef do_this_or(self):\n\t\tprint(\'You can overide me but you do not have to\')\n\nclass ConcreteClassA(AbstractClass):\n#This class inherits from the Abstract class featuring the template method. \n\n\tdef do_step_1(self):\n\t\tprint(\'Doing step 1 for ConcreteClassA ...\')\n\n\tdef do_step_2(self):\n\t\tprint(\'Doing step 2 for ConcreteClassA ...\')\n\nclass ConcreteClassB(AbstractClass):\n#This class inherits from the Abstract class featuring the template method.\n\n\tdef do_step_1(self):\n\t\tprint(\'Doing step 1 for ConcreteClassB ...\')\n\n\tdef do_step_2(self):\n\t\tprint(\'Doing step 2 for ConcreteClassB ...\')\n\n\tdef do_this_or(self):\n\t\tprint(\'Doing my own business ...\')\n\ndef main():\n\tprint(\'==ConcreteClassA==\')\n\ta = ConcreteClassA()\n\ta.template_method()\n\n\tprint(\'==ConcreteClassB==\')\n\tb = ConcreteClassB()\n\tb.template_method()\n\nif __name__ == \'__main__\':\n\tmain()\n\n```\n\x3c!-- Codeblock end --\x3e\n<br/>\n<br/>\n'},N=t(198),E=t.n(N),O=t(4),H=O.a.create({container:{paddingTop:5,paddingBottom:5,minWidth:"50%"}}),M=function(e){var n=e.titles,t=e.onlineNotes,r=e.onPressHandler;return n.map((function(e){return s.a.createElement(b.a,{style:H.container,key:e+"_view"},s.a.createElement(h.a,{title:e in t?e:e+" (local)",onPress:function(){return r(e)},key:e+"_button",style:H.button}))}))},L=function(e){var n=e.viewerCallback,t=Object(r.useState)({}),o=u()(t,2),a=o[0],i=o[1];Object(r.useEffect)((function(){return function(e){!function(){var n;p.a.async((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,p.a.awrap(k());case 2:n=t.sent,e((function(){return n}));case 4:case"end":return t.stop()}}),null,null,null,Promise)}()}(i)}),[]);return s.a.createElement(_.a,{style:E.a.container},s.a.createElement(M,{titles:function(){var e,n=[].concat(d()(Object.keys(a)),d()(Object.keys(I)));return e=n,d()(new Set(e))}(),onlineNotes:a,onPressHandler:function(e){var t;return p.a.async((function(r){for(;;)switch(r.prev=r.next){case 0:if(!(e in a)){r.next=10;break}return t=a[e].url,r.t0=n,r.t1=e,r.next=7,p.a.awrap(B(t));case 7:return r.t2=r.sent,r.t3={title:r.t1,markdownData:r.t2},r.abrupt("return",(0,r.t0)(r.t3));case 10:return r.abrupt("return",n({title:e,markdownData:x(I[e])}));case 11:case"end":return r.stop()}}),null,null,null,Promise)}}))},q=O.a.create({container:{flex:1,alignItems:"center",justifyContent:"flex-start",paddingTop:"1%"}}),F=function(e){var n=e.navigation;return s.a.createElement(c.a,{style:q.container},s.a.createElement(L,{viewerCallback:function(e){return n.push("Viewer",e)}}))},V=t(204),z=function(e){var n=e.route,t=(e.navigation,n.params.markdownData);return s.a.createElement(_.a,{contentInsetAdjustmentBehavior:"automatic",contentContainerStyle:{paddingHorizontal:"5%"}},s.a.createElement(V.a,null,t))},R=Object(i.a)();function U(){return s.a.createElement(o.b,null,s.a.createElement(a.a,null,s.a.createElement(R.Navigator,{screenOptions:{headerTitleStyle:{alignSelf:"center"},headerBackTitleStyle:{}}},s.a.createElement(R.Screen,{name:"Home",component:F,options:{title:"Notes"}}),s.a.createElement(R.Screen,{name:"Viewer",component:z,options:function(e){return{title:e.route.params.title}}}))))}},215:function(e,n,t){t(216),e.exports=t(326)},216:function(e,n){"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/notes/expo-service-worker.js",{scope:"/notes/"}).then((function(e){})).catch((function(e){console.info("Failed to register service-worker",e)}))}))}},[[215,1,2]]]);
//# sourceMappingURL=app.e96822de.chunk.js.map